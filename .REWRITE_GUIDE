Cell:
    props:
        low(u8): the value of the cell
        high(u8): the flags for the cell
    is_instruction:
        (using the high byte) check if the cell holds an instruction
        self.high & 0b10000000 != 0
    is_argument:
        (using the high byte) check if the cell holds an argument
        self.high & 0b01000000 != 0
    Display:
        only the low byte
    Debug:
        the low byte and a formatted version of the high byte depending on what's in it

ArgFlags(Builder):
    0b1<arg_type:3><arg_idx:4>
    arg_idx: The index of the current arg, (4 bits)
    arg_type: The type of the arg (2 bits, see map at bottom)

InstructionFlags(Builder):
    0b010<is_internal:1><nargs:4>
    nargs: The number of arguments this instruction needs (4 bits)
    is_internal: if the instruction is an internal call (1 bit)

Instruction:
    props:
        addr: address that points to the instruction cell in memory
        nargs: the number of arguments this instruction needs: ((memory[addr] & 0x0F00) >> 8 ) as u8

    from_str:
        Create an Instruction from a string. This should _theoretically_ be a single line of assembly
    as_str:
        create a formatted string for the instruction and the arguments
    execute:
        execute the instruction with the given arguments
    
